From 01ff4d48c82f5243cf14b2e80804f999bf98dfae Mon Sep 17 00:00:00 2001
From: driver1998 <driver1998@foxmail.com>
Date: Thu, 27 Feb 2020 20:12:32 +0800
Subject: [PATCH 5/5] ARM64 codegen_FP_ENTER out of range fix

---
 src/cpu_new/codegen_backend_arm64_uops.c | 49 ++++++++++++++++++------
 src/cpu_new/cpu.c                        |  1 +
 src/cpu_new/cpu.h                        |  5 ++-
 3 files changed, 41 insertions(+), 14 deletions(-)

diff --git a/src/cpu_new/codegen_backend_arm64_uops.c b/src/cpu_new/codegen_backend_arm64_uops.c
index e9cf2868..ddd12687 100644
--- a/src/cpu_new/codegen_backend_arm64_uops.c
+++ b/src/cpu_new/codegen_backend_arm64_uops.c
@@ -807,36 +807,58 @@ static int codegen_FP_ENTER(codeblock_t *block, uop_t *uop)
 {
         uint32_t *branch_ptr;
 
-	if (!in_range12_w((uintptr_t)&cr0 - (uintptr_t)&cpu_state))
-		fatal("codegen_FP_ENTER - out of range\n");
+        /* copy CR0 and cpu_state to a struct in order to avoid offset out-of-range */
+        struct {
+                cpu_state_t cpu_state;
+                cr0_t CR0;
+        } tmp;
 
-        host_arm64_LDR_IMM_W(block, REG_TEMP, REG_CPUSTATE, (uintptr_t)&cr0 - (uintptr_t)&cpu_state);
+        memcpy(&tmp.cpu_state, &cpu_state, sizeof(cpu_state));
+        memcpy(&tmp.CR0, &CR0, sizeof(CR0));
+
+	if (!in_range12_w((uintptr_t)&tmp.CR0.l - (uintptr_t)&tmp.cpu_state))
+		fatal("codegen_FP_ENTER - out of range\n", &tmp.CR0.l, &tmp.cpu_state);
+
+        host_arm64_LDR_IMM_W(block, REG_TEMP, REG_CPUSTATE, (uintptr_t)&tmp.CR0.l - (uintptr_t)&tmp.cpu_state);
         host_arm64_TST_IMM(block, REG_TEMP, 0xc);
         branch_ptr = host_arm64_BEQ_(block);
 
 	host_arm64_mov_imm(block, REG_TEMP, uop->imm_data);
-	host_arm64_STR_IMM_W(block, REG_TEMP, REG_CPUSTATE, (uintptr_t)&cpu_state.oldpc - (uintptr_t)&cpu_state);
+	host_arm64_STR_IMM_W(block, REG_TEMP, REG_CPUSTATE, (uintptr_t)&tmp.cpu_state.oldpc - (uintptr_t)&tmp.cpu_state);
         host_arm64_mov_imm(block, REG_ARG0, 7);
 	host_arm64_call(block, x86_int);
         host_arm64_B(block, codegen_exit_rout);
 
 	host_arm64_branch_set_offset(branch_ptr, &block_write_data[block_pos]);
 
+        /* copy those back */
+        memcpy(&cpu_state, &tmp.cpu_state, sizeof(cpu_state));
+        memcpy(&CR0, &tmp.CR0, sizeof(CR0));
+
         return 0;
 }
 static int codegen_MMX_ENTER(codeblock_t *block, uop_t *uop)
 {
         uint32_t *branch_ptr;
 
-	if (!in_range12_w((uintptr_t)&cr0 - (uintptr_t)&cpu_state))
+        /* copy CR0 and cpu_state to a struct in order to avoid offset out-of-range */
+        struct {
+                cpu_state_t cpu_state;
+                cr0_t CR0;
+        } tmp;
+
+        memcpy(&tmp.cpu_state, &cpu_state, sizeof(cpu_state));
+        memcpy(&tmp.CR0, &CR0, sizeof(CR0));
+
+	if (!in_range12_w((uintptr_t)&tmp.CR0.l - (uintptr_t)&tmp.cpu_state))
 		fatal("codegen_MMX_ENTER - out of range\n");
 
-        host_arm64_LDR_IMM_W(block, REG_TEMP, REG_CPUSTATE, (uintptr_t)&cr0 - (uintptr_t)&cpu_state);
+        host_arm64_LDR_IMM_W(block, REG_TEMP, REG_CPUSTATE, (uintptr_t)&tmp.CR0.l - (uintptr_t)&tmp.cpu_state);
         host_arm64_TST_IMM(block, REG_TEMP, 0xc);
         branch_ptr = host_arm64_BEQ_(block);
 
 	host_arm64_mov_imm(block, REG_TEMP, uop->imm_data);
-	host_arm64_STR_IMM_W(block, REG_TEMP, REG_CPUSTATE, (uintptr_t)&cpu_state.oldpc - (uintptr_t)&cpu_state);
+	host_arm64_STR_IMM_W(block, REG_TEMP, REG_CPUSTATE, (uintptr_t)&tmp.cpu_state.oldpc - (uintptr_t)&tmp.cpu_state);
         host_arm64_mov_imm(block, REG_ARG0, 7);
 	host_arm64_call(block, x86_int);
         host_arm64_B(block, codegen_exit_rout);
@@ -844,11 +866,14 @@ static int codegen_MMX_ENTER(codeblock_t *block, uop_t *uop)
 	host_arm64_branch_set_offset(branch_ptr, &block->data[block_pos]);
 
 	host_arm64_mov_imm(block, REG_TEMP, 0x01010101);
-	host_arm64_STR_IMM_W(block, REG_TEMP, REG_CPUSTATE, (uintptr_t)&cpu_state.tag[0] - (uintptr_t)&cpu_state);
-	host_arm64_STR_IMM_W(block, REG_TEMP, REG_CPUSTATE, (uintptr_t)&cpu_state.tag[4] - (uintptr_t)&cpu_state);
-	host_arm64_STR_IMM_W(block, REG_WZR, REG_CPUSTATE, (uintptr_t)&cpu_state.TOP - (uintptr_t)&cpu_state);
-	host_arm64_STRB_IMM(block, REG_WZR, REG_CPUSTATE, (uintptr_t)&cpu_state.ismmx - (uintptr_t)&cpu_state);
-
+	host_arm64_STR_IMM_W(block, REG_TEMP, REG_CPUSTATE, (uintptr_t)&tmp.cpu_state.tag[0] - (uintptr_t)&tmp.cpu_state);
+	host_arm64_STR_IMM_W(block, REG_TEMP, REG_CPUSTATE, (uintptr_t)&tmp.cpu_state.tag[4] - (uintptr_t)&tmp.cpu_state);
+	host_arm64_STR_IMM_W(block, REG_WZR, REG_CPUSTATE, (uintptr_t)&tmp.cpu_state.TOP - (uintptr_t)&tmp.cpu_state);
+	host_arm64_STRB_IMM(block, REG_WZR, REG_CPUSTATE, (uintptr_t)&tmp.cpu_state.ismmx - (uintptr_t)&tmp.cpu_state);
+
+        /* copy those back */
+        memcpy(&cpu_state, &tmp.cpu_state, sizeof(cpu_state));
+        memcpy(&CR0, &tmp.CR0, sizeof(CR0));
         return 0;
 }
 
diff --git a/src/cpu_new/cpu.c b/src/cpu_new/cpu.c
index 6b277275..cb6ac652 100644
--- a/src/cpu_new/cpu.c
+++ b/src/cpu_new/cpu.c
@@ -164,6 +164,7 @@ int		hasfpu;
 uint64_t	tsc = 0;
 msr_t		msr;
 cr0_t		CR0;
+cpu_state_t    cpu_state;
 uint64_t	pmc[2] = {0, 0};
 
 uint16_t	temp_seg_data[4] = {0, 0, 0, 0};
diff --git a/src/cpu_new/cpu.h b/src/cpu_new/cpu.h
index 18525031..06e0dfac 100644
--- a/src/cpu_new/cpu.h
+++ b/src/cpu_new/cpu.h
@@ -196,7 +196,7 @@ typedef union {
 } cr0_t;
 
 
-struct _cpustate_ {
+typedef struct {
     x86reg	regs[8];
 
     uint8_t	tag[8];
@@ -260,7 +260,7 @@ struct _cpustate_ {
 		seg_gs;
 
     uint16_t flags, eflags;
-} cpu_state;
+} cpu_state_t;
 
 /*The cpu_state.flags below must match in both cpu_cur_status and block->status for a block
   to be valid*/
@@ -357,6 +357,7 @@ extern uint16_t		cpu_cur_status;
 extern uint64_t		cpu_CR4_mask;
 extern uint64_t		tsc;
 extern msr_t		msr;
+extern cpu_state_t     cpu_state;
 extern uint8_t		opcode;
 extern int		insc;
 extern int		fpucount;
-- 
2.21.0.windows.1

